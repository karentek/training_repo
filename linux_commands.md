- ps посмотреть процессы запущенные от имени пользователя 
- top посмотреть процессы
- python simple_app.py & запуск в фоновом режиме
- python simple_app.py > /dev/null & перенаправить аутпут в никуда чтоб не мешал
- kill %1 (SIGTERM номер сигнала -9 передается через -) вместо единици число из квадратных скобок либо число без процента PID
-  python simple_app.py 2>&1 > /dev/null & у каждого процесса 3 стандартных потока, запись означает перенаправить второй в первый а первый в черную дыру
- либо тоже самое python simple_app.py &> /dev/null &
- остановить процесс с пер фона ctrl+z снова запустить на пер фоне fg
~~~
Стандартный поток ввода (stdin) — 0;
Стандартный поток вывода (stdout) — 1;
Стандартный поток ошибок (stderr) — 2.
~~~

~~~
< файл
Использовать файл как источник данных для стандартного потока ввода.
> файл
Направить стандартный поток вывода в файл. Если файл не существует, он будет создан; если существует — перезаписан сверху.
2> файл
Направить стандартный поток ошибок в файл. Если файл не существует, он будет создан; если существует — перезаписан сверху.
>>файл
Направить стандартный поток вывода в файл. Если файл не существует, он будет создан; если существует — данные будут дописаны к нему в конец.
2>>файл
Направить стандартный поток ошибок в файл. Если файл не существует, он будет создан; если существует — данные будут дописаны к нему в конец.
&>файл или >&файл
Направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >файл 2>&1.
>&-
Закрыть поток вывода перед вызовом команды (спасибо [1]);
2>&-
Закрыть поток ошибок перед вызовом команды (спасибо [2]);
cat <<EOF
Весь текст между блоками EOF (в общем случае вместо EOF можно использовать любое слово) будет выведен на экран. Важно: перед последним EOF не должно быть пробелов! (heredoc синтаксис).

EOF
<<<string
~~~

http://xgu.ru/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8_%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0/%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0


~~~
В UNIX/Linux существует целый класс команд, которые принимают данные со стандартного потока ввода, каким-то образом обрабатывают их, и выдают результат на стандартный поток вывода. Такие программы называются программами-фильтрами.

Как правило, все эти программы работают как фильтры, если у них нет аргументов (опции могут быть), но как только им в качестве аргумента передаётся файл, они считывают данные из этого файла, а не со стандартного потока ввода (существуют и исключения, например, программа tr, которая обрабатывает данные поступающие исключительно через стандартный поток ввода).

Фильтры head, tail, cat и cut показывают различные части файла
cat
Считывает данные со стандартного потока ввода и передаёт их на стандартный поток вывода. Без опций работает как простой повторитель. С опциями может фильтровать пустые строки, нумеровать строки и делать другую подобную работу.
head
Показывает первые 10 строк (или другое заданное количество), считанных со стандартного потока ввода.
tail
Показывает последние 10 строк (или другое заданное количество), считанные со стандартного потока ввода. Важный частный случай tail -f, который в режиме слежения показывает концовку файла. Это используется, в частности, для просмотра файлов журнальных сообщений.
cut
Вырезает столбец (по символам или полям) из потока ввода и передаёт на поток вывода. В качестве разделителей полей могут использоваться любые символы.
sort
Отсортировать данные в соответствии с какими-либо критериями, например, арифметически по второму столбцу.
uniq
Удалить повторяющиеся строки. Или (с ключом -с) не просто удалить, а написать сколько таких строк было. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе.
tee
Ответвить данные в файл. Используется для сохранения промежуточных данных, передающихся в потоке, в файл.
bc
Вычислить каждую отдельную строку потока и записать вместо неё результат вычисления.
hexdump
Показать шестнадцатеричное представление данных, поступающих на стандартный поток ввода.
strings
вычленить и показать в стандартном потоке (или файле) то, что напоминает строки. Всё что не похоже на строковые последовательности, игнорировать. Полезна в сочетании с grep для поиска интересующих строковых последовательностей в бинарных файлах.
grep
Отфильтровать поток, и показать только строки, содержащие (или не содержащие) заданное регулярное выражение.
tr
Посимвольная замена текста в потоке. Например, tr A-Z a-z меняет регистр символов с большого на маленький.
sed
Обработать текст в соответствии с заданным скриптом. Наиболее часто используется для замены текста в потоке: sed s/было/стало/g
awk
Обработать текст в соответствии с заданным скриптом. Как правило, используется для обработки текстовых таблиц, например таких как вывод ps aux и тому подобных, но не только.
perl
Обработать текст в соответствии с заданным скриптом. Возможности языка Perl выходят далеко за рамки однострочников для командной строки, но с однострочниками он справляется особенно виртуозно. В Perl существует оператор <> (diamond operator) и конструкция while(<>) { ... }, которая предполагает обработку данных со стандартного потока ввода (или из файлов, если они переданы в качестве аргументов). При написании однострочников можно использовать ключи -n (равносильный оборачиванию кода в while(<>) { ... }) или -p (равносильный while(<>) { ... }).
Прозрачная передача потока между хостами через SSH
sh -s
Текст, который передаётся на стандартный поток ввода sh -s может интерпретироваться как последовательность команд shell. На выход передаётся результат их исполнения.
ssh
Средство удалённого доступа ssh, может работать как фильтр. ssh подхватывает данные, переданные ему на стандартный поток ввода, передаёт их на удалённых хост и подаёт на вход процессу программы, имя которой было передано ему в качестве аргумента. Результат выполнения программы (то есть то, что она выдала на стандартный поток вывода) передаётся со стандартного вывода ssh.
~~~

- https://obu4alka.ru/poleznyh-operatorov-obedineniya-komand-v-linux.html
~~~
1. 1. Оператор амперсанда (&)
2. 2. Оператор точка с запятой (;)
3. 3. Оператор AND (&&)
4. 4. Оператор OR (||)
5. 5. Оператор NOT (!)
6. 6. Оператор AND-OR (&& — ||)
7. 7. Оператор потока PIPE (|)
8. 8. Оператор комбинации команд {}
9. 9. Оператор приоритета ()
10. 10. Оператор конкатенации (\)
~~~


### че по заданиям


~~~
python simple_app.py > file.txt 2>&1 &
~~~

- Перенаправлять поток вывода можно не только в «мусорку», но и в полезные нам места. Запустите наш тестовый flask-сервер так, чтобы выходные данные шли в файл stdout.txt, а ошибки — в stderr.txt. Запустите этот процесс в фоне.
~~~
python simple_app.py &> stdout.txt 2> stderr.txt &
~~~

- запустите flask-сервер в фоновом режиме и запомните PID процесса, объедините в один вызов запуск команды kill и запуск нового сервера (делайте это в фоновом режиме).

~~~
1 command: python simple_app.py &
2 command: kill 4868 && python simple_app.py &
~~~


Напишите функцию, которая с помощью subprocess будет запускать команду:
$ curl -i -H "Accept: application/json" -X GET
https://api.ipify.org?format=json
Токенизируйте через shlex, распарсите вывод и верните строку — IP-адрес.

~~~
command = """curl -i -H "Accept: application/json" -X GET https://api.ipify.org?format=json"""
tail_command = "tail -n 1"
def main():
    curl_res = subprocess.run(shlex.split(command), capture_output=True, text=True)
    tail_result = subprocess.run(shlex.split(tail_command), input=curl_res.stdout, capture_output=True, text=True)
    """tail_result.returncode = 0"""
    print(tail_result.stdout)
~~~

Ещё одна команда для тренировки, которую разобрали в видео, — это $ ps -A. Она выводит все запущенные в системе процессы. Посчитайте их и выведите в консоль их количество.
~~~
ps -A | wc -l
~~~

запуск нескольких процессов одновременно
~~~
import time
import subprocess


def run_program():
    start = time.time()
    procs = []
    for pnum in range(1, 6):
        p = subprocess.Popen(
            ['python', 'tes.py'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        print('process number {} started. PID: {}'.format(
            pnum, p.pid
        ))
        procs.append(p)

    for proc in procs:
        proc.wait()
        if b'Done' in proc.stdout.read() and proc.returncode == 0:
            print('process with PID {} ended successfully'.format(
                proc.pid
            ))

    print('Done in {}'.format(
        time.time() - start
    ))


if __name__ == '__main__':
    run_program()
~~~


проверить в консоли что у процесса появился код возврата(тобишь завершен процесс)
~~~
with subprocess.Popen('uptime', stdout=subprocess.PIPE) as process:
    print(process.stdout.read())
print('return code :', process.returncode)
b' 15:50:50 up 16:06,  1 user,  load average: 2,86, 1,73, 1,60\n'
return code : 0
~~~

посмотреть код возврата предыдущей проги
~~~
 echo $?
~~~